# 一、数据结构：
:::alert-info
**简述**：要解决一个现实问题，需要将其抽象，建模成数学模型，然后设计一个解此数学模型的算法，再用编程来实现，这个过程当中，不完全是数学公式的表达。数据结构是一门研究非数值计算的程序设计问题中，计算机的操作对象以及它们之间的关系和操作等的科学。1968年国外开始设计。
:::
## a、概论
- 数据结构：数据的结构分为物理结构和逻辑结构。
（1）是研讨数据的**逻辑结构和物理结构**，以及它们之间的相互关系，并对这种结构相应的**运算**，设计出相应的**算法**。
（2）是带有结构的`数据元素`的集合。
（3）研究内容包括：数据如何存储、数据如何组织、数据的运算如何实现。
- 数据类型：程序设计语音中的概念，如c中的整型、字符型。
- 抽象数据类型（ADT）：一个数学模型及定义在该模型上的一组操作，与计算机内部如何表示和实现无关。3个组成部分分别为：数据对象、数据关系、基本操作。
- 数据的运算：对数据定义的一组操作，定义在逻辑结构上。
- **数据的物理结构**：循环队列、链表、顺序表、散列表、索引
（1）是指数据在计算机内存储的实际形式。
（2）数据结构中，数据的**基本单位**是`数据元素`，数据的**最小单位**是`数据项`
（3）包括**数据元素**的表示和**数据元素间关系**的表示。
（4）数据对象是指性质相同的数据元素的集合。
- 逻辑结构：可分为线性结构、非线性结构。也可分为线性结构、集合、树、图。
（1）线性结构：栈、队列、字符串、线性表。
（2）非线性结构：广义表、集合、树、图

**算法**：解决问题的步骤序列。（注意是问算法的特性，还是效率）
- 算法的5个特性：有穷性、确定性、可行性、有零个或多个输入、有一个或多个输出。**算法的可行性**是指指令不能有二义性。
- **评价算法质量**：正确性、易读性、强壮性、高效率。
- 算法复杂度：（算法的计算量大小）有时间复杂度和空间复杂度来衡量。 
- **时间复杂度**：
（1）取决于`问题的规模`，和`待处理数据的初态`。
（2）有两种方法：**事后统计**(由于使用的编程语言不同，计算机硬件不同等会导致得到的时间不一样，所以往往不适应这种方法)、
**事先预估**(一个算法由控制结构(顺序、分支、循环)和原操作(固有数据类型的操作(加、减、赋值、...))构成，算法时间取决于两者综合效果)。例如：
```java
// 平方阶-->O(n^2)
for(int i=0;i<n;i++){
    for(int j=0;j<n;j++){c[i][j] = 0;}// 时间复杂度为O(n^2)
}
// 对数阶-->O(log_2[n])
while(x<n){x = 2*x;}
// 对数阶-->O(nlog_2[n])
for(k<1;k<=n;k*=2){
    for(j=1;j<=n;j++){count++;}
}
// 根号阶-->o(\sqrt{n})
int s = 1;int i = 1;
while(s<n){s += ++i;}
//s的执行次数为：(n+3)(n-2) / 2
for (int i = 1; i < N - 1; i++) {
    for (int j = N; j >= i; j--) {
        System.out.print('>>', i, j, num);
        num += 1;//s
    }
}
```
（3）算法中基本重复执行的次数是问题规模n的某个函数f(n)，算法时间度量记做：`T(n) = O(f(n))`。
（4）时间复杂度还可能呈现的形式有：O(1)、O(n)、O(n^2)、O(log(n))、O(2^n)#分别是常量阶、线性阶、平方阶、对数阶、指数阶。<b c=v>赋值、计算这些不用计算在时间复杂度之内</b>
>如果遇到分支，可能某些基本操作就不需要执行，那么即使这个基本操作在循环中也是不计次数的，这种情况以算法最糟糕的情况来计算其时间复杂度。
>即使有了这些方法，计算时间复杂度依然不是那么准确的，比如算法很复杂的情况，各编程语言中调用的内置函数的时间。
（5）相同规模n下复杂度O(n)的算法，时间上总是优于复杂度`O(2^n)`的算法。
（6）同一算法语言实现的级别越高，效率越低。

## 一、线性表：
最常用，最简单的一种数据结构，一个线性表是n数据元素的有限序列，一个数据元素可以是一页书，可由若干数据项组成，这种情况下常把数据元素称为记录，含有大量记录的线性表又称文件。各编程语言中的列表型数据和线性表类似但两者定义有点区别。<i c="gn">(同一线性表中的元素有其相同特性，对线性表的数据不仅可以进行访问还可以插入、删除等。)</i>

**顺序存储**：是一种`随机存取`的存储结构。（所以逻辑顺序与物理顺序不一定一致）
（1）逻辑关系上相邻的两个元素在物理位置上也相邻，可随机存取表中任意元素，存取位置可以用一个简单直观的方式来表达，
（2）在插入和删除时需要对应位置后面所有的元素都需要向后或向前移动一位，这可能会需要移动大量元素，耗费很多时间。
（3）随机存取时的时间复杂度都是`O(1)`，插入删除时的时间复杂度都是`O(n)`.
（4）示例：某线性表最常用的操作是存取任一指定序号的元素，和在最后进行插入删除操作，则利用**顺序表**存储方式最节省时间。
（5）示例：一个链表常用的操作是在末尾插入和删除节点，则用**带头节点的双循环链表**最合适。
**链式存储**：
（1）可以用一个任意的存储单元存储线性表数据元素，可连续也可不连续，为了表示出任意元素ai的后继节点，所以在存储元素点时还会存储其后继元素点的位置，如下表：
| 存储地址    |  数据域   |  指针域   |
| :-: | :-: | :-: |
|  1   |  a   |  3   |
|   7  |  e   |  9   |
|   5  |  c   |   6  |
|   3  |  b   |  5   |
|   6  |  d   |  7   |
（2）指针域指向的是其后继节点所在的存储地址。还需要一个头指正H来表示从哪一个开头，如H=1，它们间的逻辑顺序就为：a →b →c →d →e →...。
（3）这种存储结构在逻辑相邻的元素其存储的物理位置上不紧邻，也称为链式映像。 插入和删除时只需要修改指正即可，不需要移动大量元素。这种链表也称为**线性链表**。
（4）增加一个头节点目的是方便运算，统一插入、删除等运算。
**循环链表** ：另一种形式的链式存储结构，特点是最后一个节点的指针域指向头指针，形成一个环，因此从任意位置出发都可以找到其它节点。
**双向链表**：单向链表中要从一个节点出发查找目标节点其时间复杂度在：O(1)~O(n-1)间，为了能更快速的查找可以存储两个指针域，即后继节点位置和前驱节点位置。
```c++
/*===========================
    链表的表示，链表的基本操作
=============================*/
typedef struct LNode {
	int data;
	struct LNode* next;
}LNode,*LinkList;
// 初始化头结点。
bool Link_InitList(LinkList &L) {
	L = new LNode;
	L->next = NULL;
	return true;
}
// 插入：L为指针，i为插入位置，e为节点数据。
bool Link_Insert(LinkList& L, int i, int e) {
	LinkList p = L;
	int j = 0;
	// 将p指向第i-1个节点。
	while (p && (j < i - 1)) {
		p = p->next;
		++j;
	}
	if (!p || j > i - 1) return false;
	auto s = new LNode;			//新建一个节点。s变为指针
	s->data = e;			
	s->next = p->next;		//指针更新
	p->next = s;			//插入
	return true;
}
// 取值：指针、位置、数据域
bool Link_Get(LinkList L, int i, int& e) {
	auto p = L->next;
	int j = 1;
	// 不断的指向下一个节点。
	while (p && j<i) {
		p = p->next;
		++j;
	}
	if (!p || j > i) return false;

	e = p->data;
	return true;
}
// 删除
int Link_delete(LinkList& L, int i) {
	auto p = L;
	int j = 0;
	while ((p->next) && (j<i-1)) {
		p = p->next;
		++j;
	}
	if (!(p->next) || (j > i - 1)) return false;
	auto q = p->next;
	p->next = q->next;
	delete q;
	return true;
}
```
## 二、栈和队列：
栈和队列也是线性表，其特殊性在于栈和队列的操作是线性表操作的子集，因此可以称为限定性的数据结构。
**栈**：是限定仅在表尾进行插入或删除操作的线性表，表尾端称为栈顶，表头端称为栈底。不含元素的空表称为空栈。所以栈又称为后进先出的线性表。
- 顺序栈：将元素用顺序存储结构中。
- 链栈：将元素用链表形式存储，比起顺序栈来不会出现栈满情况。

**队列**：和栈相反，队列是一种先进先出的线性表，它只允许在表的一端进行插入，在表的另一端进行删除元素。只允许插入的一端是队尾。
**链队列**：和线性表一样，队列中也可存储指针域，不过还需要指定一个尾指针，当头指针和尾指针同时指向头节点时称为空的连队列。
**双端队列**：在队列两端都允许插入和删除操作，或在这基础上自定义限制。

```c++
/*=======================
	栈的链式表示
=========================*/
bool Inn_LinkInit(Inn_Link &S) {
	S = NULL;											//栈初始只要一个指针即可。
	return true;
}

// 入栈
bool Inn_LinkPush(Inn_Link &S,int e) {
	auto p = new Inn_Node;								//新的节点
	p->data = e;
	p->next = S;										//新的节点作为栈顶
	S = p;
	return true;
}
// 出栈
bool Inn_LinkPop(Inn_Link& S, int e) {
	if (S == NULL) return false;						//空栈情况！
	e = S->data;
	auto p = S;
	S = S->next;
	delete p;											//上面的赋值是为了这里释放？？
	return true;
}
int Inn_LinkGet(Inn_Link S) {
	if (S != NULL) {
		return S->data;
	}
	else {
		return -999;
	}
}
```
部分使用场景：
- 设计一个判别表达式，求其中左右括号（[]）是否成对出现，用`栈结构`最好。递归过程或函数调用时，处理其参数要用多维数组处理。
- 将递归算法转变成对应非递归算法时，需要使用`栈`，来保存中间结果。
- 普通队列的存储更适合使用`单向循环链表`。
- 树的前、中、后序遍历使用**栈**更容易实现。<b c=b>层次遍历使用队列更容易实现。</b>

## 三、串&数组&广义表：
字符串一般简称为串，在汇编和语言的编译程序中，源程序和目标程序都是字符串数据。由0个或多个字符组成的有限序列就称为串，一般记为s='a1a2...an'。零个字符的串称为**空串**。串中任意连续个字符称为该串的**子串**，包含子串的串相应地称为**主串**。包含一个或多个空格的串称为**空格串**。子串起始字符在主串中出现的位置即为该子串的位置。
串的存储：也像线性表存储那样，串可以用顺序存储和链式存储，链式存储时，一些子串可以是多个字符。

这也是两种数据结构，数组和广义表可以看成是线性表的一个定义扩展——表中的数据元素也是一个数据结构。两者的定义都是一大段伪代码表示的。
**数组**：如果有一维中的一个元素是一个数据结构的话，那么其它元素也是相同的数据结构，且长度相同。数组一旦被定义，它的维数和维界就不再改变，除了初始化和销毁之外，数组只有存取元素和修改元素值的操作。所以一般采用**顺序存储**的方式。分按行的顺序存储和按列的顺序存储。对**对称、稀疏这类特殊矩阵可进行压缩存储**。示例如下：
>用**三元组线性表**表示出数组中非0位置的值：`((1,5,1),(3,2,-1),(4,5,-2),...)`序号从1开始，前两个值为行号和列号，第3个值为存储值。**顺序存储表示**时将这些当行写在表里，然后最上面加上`行数|列数|数值个数`。

**广义表**：线性表的推广，也有人称其为列表，与数组不同的是，广义表中的数据元素可以具有不同的结构(如一个是a，一个是一个子表)，因此难以用顺序存储结构表示，通常采用链式存储结构。所以广义表比线性表更灵活。程序语言设计中的列表可以说是一个广义表的设计。
**广义表的存储**：由于广义表的特殊结构需要两个存储结构，一个存储所有广义表数据，另一个存储各元素对应的数据类型，指针。数据存储：无论是原子数据还是列表数据，其中每个元素都被分开一个个存到物理地址中，一个列表中的数据连续的存储到地址中。指针域存储：一个tag指针表示该元素数据类型，一个头指针，一个尾指针(分别指向该列表的表头和表尾)，原点数据只需一个。
## 五、树：
:::alert-info
堆、栈、队列等数据结构在查找时非常费时间，而用树数据结构可以提高查询效率，且现实中很多关系符合树的结构，树的第一层只有一个节点即根节点(没有父节点的节点)，其余为子节点，每个节点可有多个子节点和一个直接父节点。一种非线性的数据结构，树和二叉树最为常用。第一个节点为根节点，子节点数不为0的节点称为分支节点后非终端节点，字节点数为0的节点称为叶子节点或终端节点，节点的分支数称为度，字节点称为孩子节点，该节点称为其双亲。 
:::

无序树：树中任意节点的子结点之间没有顺序关系,这种树称为无序树,也称为自由树;
有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树；
**度**：每个节点拥有的子节点称为该节点的度，**树的度**指该树内节点度数最大的。可以发现一个有N个节点的树，其所有节点的**度数和为N-1**。
**二叉树**：与树一样具有递归性质。每个节点最多有两个子节点，节点有左右之分。
- 二叉树可以为空，但树不能为空。
- 二叉树不是树的特例。是**有序树**。**性质如下**：
1. 第k层最多有`2^(k-1)`个节点，为k层的树最多有`2^k-1`个节点。 对于3叉，4叉树等，第k层节点数公式，只要将2替换为对应数值即可。
2. **满k叉树情况**：
（1）将满k叉树节点分为叶子节点a，分支节点（非叶子节点，包含根节点）b。
（2）有节点总数`n=a+b=bk+1`
3. 链表存储二叉树时，n个节点的二叉树有2n个指针域，n-1个空指针。（**不要算上头指针**）

**m叉树叶子节点数公式**：$S=1+\sum_{i=1}^{m}(i-1)n_i,\space n_i$是度i的节点数。m是树的度
例：一颗度为4点树T中，有20个度为4的节点，10个度为1的节点，1个度为2的节点，10个度为3的节点，求叶子节点数？
>解析：`s=1+(1-1)*10+(2-1)*1+(3-1)*10+(4-1)*20=1+0+1+20+60=82`
4. **中序序列个数**：中序序列为1,2,..,n的二叉树，其二叉树情况可能有$\frac{1}{n+1}\frac{2n!}{n!*n!}$种。


**满二叉树**：除最后一层无子节点外其余层节点均有两个子节点；
**完全二叉树**：二叉树的最后一层可以不完整但其余层的节点达到最大值且最后一层的节点全部集中在左侧。
- 检测完全二叉树的算法：<b c=v>使用堆结构（利用堆特性）来存储遍历的树节点，若是完全二叉树最后必会有连续的空缺(>=0个)。</b>
- 若有不连续节点，或总节点数不在$(2^{n-1}-1,2^n - 1)$内则不是
```c++
// 树初始化
bool Tree_Init(cLink &B) {
	B = new cNode;
	B->lchild = NULL;
	B->rchild = NULL;
	return true;
}
/*递归创建树：将A中的值保存到每个节点。cLink B = new cNode。i为A的索引。*/
cLink Tree_Create() {
	int x;
	cLink bt;
	cout << "please input a number:";
	scanf_s("%d", &x);	//数据输入。
	if (x == 0) bt = NULL;
	else if (x > 0) {
		// malloc() 分配指定长度字节的内存空间。
		//bt = (cNode*)malloc(sizeof(cNode));
		bt = new cNode;
		bt->data = x;
		bt->lchild = Tree_Create();
		bt->rchild = Tree_Create();
	}
	else {
		// 退出输入
		system("exit");
	}
	return (bt);
}
// 计算二叉树深度
int Tree_Depth(cLink T) {
	if (T == NULL) return 0;
	else {
		// 到最后叶节点才会开始返回0，然后逐级返回+1。
		int m = Tree_Depth(T->lchild);
		int n = Tree_Depth(T->rchild);
		if (m > n) return (m + 1);
		else return (n + 1);
	}
}
```
**树的存储**：（不只是二叉树）存储类型上分为：
- **顺序存储**：将各节点编号，依次从上到下，从左到右的存储节点即可。最坏的存储情况是：k层只有k个节点，却需要一个`2^k-1`长的一维数组，因为遇到空的节点要用0或其它占位表示。
- **用链式存储**：存储每个节点时再存储左右指针域即可，这称为二叉链表，如果再多存一个父节点的指针域则称为三叉链表 。
- 存储方法上分为以下几种：
1. 双亲表示法：所有节点存储在一个连续空间，每个节点有数据域，还有一个**指向父节点的指针域**。优点：易于实现，容易求树的根。
2. 孩子表示法：使用多重链表，每个节点有多个指针，每个指针指向它的1个孩子节点。
3. 孩子兄弟法：每个节点有两个指针域，一个指向自己的第一个孩子，另一个指向下一个兄弟节点。<b c=v>优点：便于将一般的树转换为二叉树处理。</b>

**二元表达式存储**：只有`+-*/`运算。
- 3种扫描方式：
    1. **前缀表达式**：从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个元素，用运算符（栈顶元素 op 次顶元素）对它们做相应运算，并将结果入栈。
    重复以上操作直到扫描完表达式。如：`(3+4)×5-6 对应的前缀表达式为 -×+3456`。
    2. **中缀表达式**：与算式顺序一样，便于人类理解，但对计算机不友好。
    3. **后缀表达式**：从左至右扫描表达式，遇到数字时，将数字压入栈中，遇到运算符时，弹出栈顶的两个数，用运算符（次顶元素 op 栈顶元素）对它们做相应的计算，并将结果入栈；
    重复上述过程直到扫描完表达式。比如 `(3+4)×5-6，对应的后缀表达式为 34+5×6-`//注意：虽然是按栈式存储和拿出的，但在**数之间运算时是反过来的**。
- **二元表达式树的存储**：<b c=v>叶节点都是数值，非叶节点都是字符</b>。
（1）一般每个节点用`{left(左指针),val(数值),data(符号),right(右指针)}`格式存储。
（2）先序遍历得到前缀表达式，中序遍历得到中序表达式，后序遍历得到后缀表达式。如下图，表达式为：`a+b*c + (d*e +f)*g`
![二元表达式](vx_images/4955823249482.png =460x)

- 计算树中存储的二元表达式：[参考学习地址](https://blog.csdn.net/qq_44322357/article/details/90200095)
```c++
int calc(cNode p){
    // left:指向左节点；right：指向右节点；val:子表达式式值；data:子表达式中的字符
    int lv,rv;
    if(C){
        if(!p->left && !p->right) return p->val;              //左右节点为空的情况。开始返回
        else{
            lv = calc(p->left);
            rv = calc(p->right);                              //递归计算左右
            switch(p->data){
                case "+":p->val = lv + rv;break;              //左节点的值+右节点的值
                case "-":p->val = lv - rv;break;
                case "*":p->val = lv * rv;break;
                case "/":p->val = lv / rv;break;
            }
            return p->val;
        }
    }
}
```

**森林**：多颗树放一起就是森林。下图为森林，树的互转。<b c=b>森林F中叶子节点个数等于树T中左孩子指针为空的节点个数</b>
- **森林转二叉树**：森林F={T1,T2,..Tn}，转为二叉树B。**方法**：<b c=gn>每个T都用单链表表示（右节点部分连接到左兄弟节点上）</b>
（1）若F为空，则B为空。
（2）从F中取走T1，T1的根节点作为B的根节点，其余都在B的左节点上。
（3）从F中取走T2，作为B的右节点部分。
（4）取走T3，其根节点连接到T2的根节点右侧。依次递增执行4。
- 二叉树转森林：<b c=b>只有右节点的，都连接到其爷爷节点上。</b>
（1）若B为空，则F为空。
（2）若B不为空，则B的根节点及其连接的左子树作为森林的第一颗树。B右节点部分中，有右子树的都分开作为森林的一颗树。

![tree1](_v_images/4475039221052.jpg =350x)                                ![tree2](_v_images/3676640239478.jpg =184x)

**线索二叉树**：当以二叉链表来存储树，在查找时只能知道某个节点的左右子树，却不知道其前驱和后继，这只有在动态查找过程中才能得到的。
- 方法如下：在二叉链表的基础上再添加两个标志域，记为：LTag，RTag，LTag为0时表示有左节点，左指针域指向其左节点，为1时左指针域指向其前驱，RTag类似。
- 这种二叉链表称为线索链表，指向节点前驱和后继的指针较线索。加上线索的二叉树称为线索二叉树。

**二叉查找树(二叉排序树、二叉搜索树)**：左子树上所有节点的值都小于根节点的值，右子树上所有节点的值都大于等于根节点的值，二叉查找树查找效率与树形有关，当节点呈单枝排列时效率最低。
**平衡二叉树**：又被称为AVL树（有别于AVL算法），**性质**：<b c=gn>左右两个子树的高度差的绝对值不超过1</b>，并且左右两个子树都是一棵平衡二叉树。
- 构建：像构建二叉查找树一样构建，但插入了一个节点后要该节点部分是否失去平衡，若失去平衡，要根据：<b c=gn>当前节点、其父节点、爷爷节点的大小来对这3各点旋转</b>，达到平衡。

**哈夫曼树(最优二叉树)**：每个节点有权重（没有则默认为1），路没有权重。哈夫曼树是使带权路径长总和最小的树。
- 带权路径长度：（WPL）节点权重x根节点到该点的最线路的路径数
（1）(如：根节点到叶节点a经过两条路径，a点权重为8，则该条路径长度`WPL=8*2`)。
（2）整颗树的WPL=各叶节点权重x各叶节点对应路径数 之和。（因为哈弗曼树是构建出来的非叶节点部分都是组合出来的，非自带节点）

- **构建过程**：
1. n颗二叉树的集合：F={T1,T2,...}，其左右子树均为空(初始时全部是节点状态)，选最小的两个权值节点构建二叉树(作为左右节点，小在左，大在右)，两节点权值之和为它们的根节点的权值。
2. 将这个新构建好的二叉树放到F中，删除F中之前用于构建二叉树的两个节点(二叉树)，重复步骤a。

**前缀编码**：编码方案中，若任一个编码都不是其它编码的前缀，则称为前缀编码。
**哈夫曼编码**：对一颗具有n个叶子的哈夫曼树，对树中每个左分支赋予0，右分支赋予1，从根节点到每个叶子路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。
- 性质：哈夫曼编码时前缀编码，且是最优前缀编码。
- 理解：例如，在英文中，e的出现机率最高，而z的出现概率则最低。当利用哈夫曼编码对一篇英文进行压缩时，e极有可能用一个比特来表示，而z则可能花去25个比特。
用普通的表示方法时，每个英文字母均占用一个字节，即8个比特。二者相比，e使用了一般编码的1/8的长度，z则使用了3倍多。
倘若我们能实现对于英文中各个字母出现概率的较准确的估算，就可以大幅度提高无损压缩的比例。
**示例**：保存文本`ACBDCBBAO`的时候每个字符占1个字节，所以一般会转为其对应的二进制编码0001形式的，这样每个字符只占四位或更短，为了最小化每个字符的前缀编码(能唯一识别每个字符的编码)，可以使用赫夫曼树，先计算各字母频率，同乘10或100转为整数作为它们的节点权重，建立最优二叉树，左分支为0，右分支为1，然后从根节点查找各个节点的路径表示就是各个字母的最小前缀编码。在解码时按照最短前缀到最长前缀从编码中一一扫描匹配。

**树的遍历**：
1. 前序遍历:先排中间节点再排左子树节点最后排右子树节点；中 | 左 | 右
2. 中序遍历:先排左子树的节点再排中间节点然后排右子树节点；左 | 中 | 右
3. 后序遍历:先排左子树节点再排右子树节点最后排中间节点；左 | 右 | 中

算法程序中常用的基本方法：
- 递归：函数通过调用自身，达到一直循环处理数据的方法。
- 迭代：通过for、while循环，将上一次循环的结果，作为下一次循环的依赖。
- **分治法**：分治法可以通俗的解释为：把一片领土分解，分解为若干块小部分，然后一块块地占领征服，被分解的可以是不同的政治派别或是其他什么，然后让他们彼此异化。
分治法的精髓：分--将问题分解为规模更小的子问题；治--将这些规模更小的子问题逐个击破；合--将已解决的子问题合并，最终得出“母”问题的解；
- **回溯法**：一种优先搜索法，又称为试探法，按优先条件向前搜索，但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

**回溯与树的遍历**：回溯法也是设计递归过程的一种重要方法，例如：求集合A={1,2,3}的所有子集，从根节点(空集)每次向前探索，左子树选择一个节点a，而右子树放弃该节点，依次这样进行递归。

**红黑树**：一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。
红黑树是一种特化的AVL树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。 它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。
- 红黑性质：节点是红色或者黑色、 根节点是黑色、每个叶子的节点都是黑色的空节点（NULL）、每个红色节点的两个子节点都是黑色的。从任意节点到其每个叶子的所有路径都包含相同的黑色节点。按这些性质组合起来几乎就是每条路径上红黑节点相间的状态。
- 插入与删除：在插入一个新的节点后可能会破坏上面红黑树的几条规则，比如一个值恰好插入到倒数第二层的一个节点(倒数第一层都是空节点黑色)，这个倒数第二层节点是红色，所以把新插入的这个节点着为红色或黑色都不符合规则。调整：从下往上尝试改变每个点颜色，若到根节点颜色更改都失败则需要尝试旋转节点。
[红黑树操作详解学习地址。](https://baijiahao.baidu.com/s?id=1641940303518144126&wfr=spider&for=pc)

**森林转为树**：森林中将各颗树的各节点保持只有一个子树（各节点的右子树放到其它节点右子树上）。然后拼接为一棵树。

<b c=v>最优二叉树编码文本实操。红黑树为什么引入红黑性质！</b>

## 六、图：
:::alert-success
**简介**：图是一种较线性表和树更为复杂的数据结构，图中任意两个数据元素之间都可能有关系，也可能图中的某个点和其它点都没有关系，图是一种数据结构，加上一组基本操作就构成了抽象数据类型。图的使用非常广。
:::
**相关术语**：

- 边/顶点/度：图中数据元素通常称作顶点，v,w是两个顶点，若`<v,w>∈VR`(两顶点之间的关系集和)，v为弧尾巴，w为弧头，此时的图称为有向图。
若`<v,w>∈VR`必有<w,v>∈VR则此时的图为无向图。以节点v为弧头的弧的数目称为节点v的**入度**，以v为弧尾的弧的数目称为v的**出度**。

- 图的最大边数：n个顶点的图的最大边数：$C ^2_n$#一个排列组合问题而已。
- **无向完全图**：用n表示图中节点，e表示图中边或弧的数目，对于无向图，`e∈(0,n*(n-1) / 2)`,有`n*(n-1) / 2`条边的称为**无向完全图**。<b c=b>不是最大边数</b>
- **有向完全图**：对于有向图，其`e∈(0,n*(n-1))`,而有`n*(n-1)`条边的是**有向完全图**。
- 稠密/稀疏：有很少的边的称为**稀疏图**，反之称为**稠密图**。与图的边或弧相关的数叫**权**，带权的图称为**网**。
- 生成树：按照图的顶点的连接，转化为树结构，一般去掉一条边就是一种生成树情况。
- **最小生成树**：根据图的结构来构建最小生成树，解决最低代价**构建连通图**问题。<b c=v>各节点的权重和最小的树称为最小生成树。</b>
- **环**：从点v到v'经过一系列点`E={v,v0,...,v'}`则称该序列点为**路径**。
（1）序列中点不重复出现的路径称为**简单路径**。
（2）第一个节点和最后一个节点相同称为回路或**环**。
（3）其它顶点不重复出现的回路为**简单回路**。
- **连通图**：无向图的一条路径中称第一个顶点和最后一个顶点v与v'是连通的，<b c=b>直接相连才叫连通</b>
（1）如果该无向图中任意两个点都是连通的则称该图为**连通图**，
（2）无向图的极大连通子图称为该图的**连通分量**。<b c=gn>一个有n个节点的图最少有2个连通分量，最多有n个连通分量</b>
（3）对于有向图则相应的称为**强连通图**和**强连通分量**。
- 无向连通图特性：
（1）所有顶点的度之和为偶数。
（2）n个顶点的连通图所需边数：s=n(n-1)/2。<b c=b>n个顶点的连通无向图至少需要n-1条边，有向图至少n条边</b>

**图的存储**：由于最小边或弧数与最大数可能相差较大，这回浪费很多存储单元，而如果为不同边或弧数的分组存储又会为后面图的操作带来难度，因此很少使用该存储方式。

- **数组表示法**：**邻接矩阵**
（1）用一个一维数组存储所有节点，再用一个二维数组存储各节点的关系。
（2）如果是一个无向图其得到的数组是对称的<i c=gn>(一般0表示无连接，1表示有连接，主对角线用0表示。如果是带权的边可将1换成对应的权值)</i>
（3）观察它是不是一个对称的，来判断它存储的是有向图还是无向图，以此来还原。
（4）删除操作：由于矩阵创建之后元素不能再删除，所以这里的删除只是改变值，让其在意义上不再是边或点。
===[1] 删除边：只需要把对应位置的点置为0即可，无向图需要将对称位置也置0。
===[2] 删除点：将该点对应行和列都置0，然后将该顶点列、行移动最后。
（5）可以只存储一个上三角或下三角矩阵。得到的关系矩阵称为邻接矩阵。如下：上三角矩阵存储为一维为：`4|6|∞|∞|∞|5|∞|∞|∞|4|3|∞|∞|3|3`
>解析：只存储了上三角部分，而主对角线都是0，且是6个节点，所以还原为：
$\left|\begin{array}_0&4&6&∞&∞&∞\\∞&0&5&∞&∞&∞\\∞&∞&0&4&3&∞\\∞&∞&∞&0&∞&3\\∞&∞&∞&∞&0&3\\∞&∞&∞&∞&∞&0\end{array}\right|$
>**缺点**：不便于增加删除点、不利于统计边数、空间复杂度高。

```c++
// 邻接矩阵存储图。时间复杂度：O(n^2)
bool CreateUDN(cInfo &G) {
	int x, y;
	// 输入节点数、边数
	cin >> x >> y;

	G.vexnum = x;
	G.arcnum = y;
	int val;
	cout << "please node-data \n";
	// 初始化权重
	for (int i = 0; i < G.vexnum;++i) {
		cin >> val;
		G.vexs[i].data = val;

		for (int j = 0; j < G.vexnum; ++j) {
			G.arcs[i][j] = MAX;
		}
	}
	int v1, v2,w;
	for (int k = 0; k < G.arcnum;++k) {
		cin >> v1 >> v2 >> w;			//
		// 查找值索引。
		int i = nodeIndex(G.vexs,v1);
		int j = nodeIndex(G.vexs, v2);
		G.arcs[i][j] = w;
	}
	return true;
}
```

- **邻接表**：图的一种链式存储结构;
（1）邻接表中对图的每个顶点建立一个单链表，以每个顶点作为头节点都建立一个单链表（边节点构成）。
（2）每条边用一个边节点存储。n个顶点e条边进行广度优先遍历时，时间复杂度：O(n+e)
（3）路由表示适合用邻接表存储。
>**优点**：便于增加删除顶点、空间效率高、便于统计边数。**适合边稀疏**，边的信息较多的情况。
>**缺点**：不便于判断顶点间是否有边、存储有向图时不便于计算各节点的度（找入度时困难）。
    - 存储无向图时，求边总数：遍历顶点表，每个顶点的边链表，最后边总数/2即是所有边数（每条边存储了两遍）
    - **存储有向图时**：顶点的`firstarc`指向其第一条出度边。【如上右图】
    - **逆邻接表**：指存储有向图时，`firstarc`指向第一条入度边。
    >邻接表转逆邻接表思路：循环遍历顶点表，读取各顶点的firstarc指针，根据其所指边节点的adjvex，ilink变换调整，重建个边节点保存，插入到对应位置即可
![ljieb](_v_images/20210406230847202_18605.png =400x)            ![](vx_images/39440211162.png =500x)

```c++
// 创建邻接表，存储无向图
bool CreatLinkTable(cInfo &G) {
	int idx = 0;
	cout << "\n p1ease input pointNum(<=BOX_LEN) vexNum\n";
	cin >> G.vexnum >> G.arcnum;
	cout << "p1ease number of BOX_LEN\n";
	// 存储节点表    《或者去除这步，下方输入边时再建立顶点，存入》
	for (int i = 0; i < G.vexnum; ++i) {
		cin >> G.vexs[i].data;
		G.vexs[i].lchild = NULL;
	}
	int v1, v2,i,j,weight;
	cout << "\nplease input node1 node2 vWeight\n";
	// 输入每条边信息
	for (int k = 0; k < G.arcnum;++k) {
		cin >> v1 >> v2 >> weight;
		i = nodeIndex(G.vexs,v1);
		j = nodeIndex(G.vexs,v2);

		auto p1 = new EBox;					//新建边节点
		p1->weight = weight;
		// 因为parent本身就是个指针，所以这里得取其地址。
		p1->ilink = G.vexs[i].firstarc;		//下一条边指向该节点的第一条边指针（这样省去了对该节点所有依赖边进行遍历）
		p1->adjvex = j;						//下一个节点在表中的序号。
		G.vexs[i].firstarc = p1;			//顶点第一条边指向pl

		auto p2 = new EBox;
		p2->weight = weight;
		p2->ilink = G.vexs[j].firstarc;
		p2->adjvex = i;
		G.vexs[j].firstarc = p2;
	}
	return true;
}
```

- **十字链表**：**有向图**的一种链式存储结构。有顶点顺序表、边链表组成。
>**弧链表**：（1）尾域(tailvex指示弧尾顶点所在位置)（2）头域(headvex指示弧头所在位置)；（3）链域hlink指向弧头相同的下一条弧
（4）tlink弧尾相同的下一条弧（5）info域存储该弧相关信息，弧头相同的在同一链表上，弧尾相同的也在同一链表上。
>**顶点表**：所有顶点，存储在一个顺序表中。<b c=r>每个顶点有`firstin`指向第一条入度边，`firstout`指向第一条出度边</b>
![数据结构](vx_images/5276251231161.png =409x)                        ![数据结构](vx_images/1973411019588.png =505x)

- **链接多重表**：**无向图的存储结构**，在一些边的相关操作时邻接表很不方便，这时可以使用链接多重表。与十字链表差别不大
（1）顶点节点中添加了一个mark字段，用于表示是否被搜索过。
（2）因为是无向图，所以一条边只有一个边节点存储（十字链表中，同一条边即存于尾链表又存于头链表）
（3）边节点中Ivex指向点1，jvex指向点2，ilink指向节点1的下一条边，jlink指向节点2的下一条边

```c++
void st(){
    ...
    // ---十字链表关键部分----
    bnode->headvex = i;              //弧头所指
    bnode->tailvex = j;              //弧尾所指
    bnode->hlink = G.vexs[i].firstin;     //相当于从其第一个所指边节点处插入，而不是从最后一个边节点添加
    G.vexs[i].firstin = bnode;            //替换节点所指的第一个边节点。
    // 弧尾所指节点更新。
    bnode.tlink = G.vexs[j].firstout;
    G.vexs[j].firstout = bnode;           //替换其第一个出度节点。
}
```

**图的遍历**：类似树的遍历，不过更为复杂。<b c=b>对图中各顶点遍历一次，仅仅一次</b>
- 深度优先搜索：从当前点触发出发，如果有字节点，则遍历，若子节点还有字节点，则继续深入。
- 广度优先搜索：先遍历当前节点的所有一级字节点，再遍历其子节点的所有一级子节点。

**最小生成树**：根据图的信息，生成一颗边的代价最小的树。<b c=r>代价总是唯一的，存在几条最小路径时，从各节点开始，最后结果可能不唯一</b>
- **普里姆算法**：适合**边密集的情况**。步骤：
（1）先从图中获取顶点集合`U={u0,...,un}`，边集合`V={u0-u1,...}`，每条边是有权值大小的，空集合TV={}。
（2）从V中选取最小的边ui-uj，放入VT，然后再从V中选择**与ui和uj相关**的边中最小的边放入VT。<b c=v>注意是从边开始，而不是顶点</b>
（3）重复步骤2<b c=v>（注意找与VT中相关的节点）</b>，<b c=gn>并注意不能形成回路。每个节点可以超过两条边。</b>
- **克鲁斯卡尔算法**：适合于求**边稀疏的网**的最小生成树。步骤：
（1）令最小生成树的初始状态为只有n个顶点而无边的非连通图T=（V，{}），图中每个顶点自成一个连通分量。
（2）在E中选择代价最小的边，若该边依附的顶点分别在T中**不同的连通分量**上（避免回路），则将此边加入到T中（对应连通分量变大）；否则，舍去此边而选择下一条代价最小的边；
（3）依此类推，直至T中所有顶点构成一个连通分量为止 。

**图的最短路径问题**：很多问题可以抽象成图的概念，我们需要从中选择最合适的路径来解决问题。
- **迪杰斯特拉算法**：<b c=r>求的是原点到其余各点的最短路径</b>。分为两个集合：
（1）第一个集合S是已求出的到v0（起始点）最短路径的终点集合。
（2）第二个集合V-S是尚未求出最短路径的顶点集合。
（3）按与v0直接/间接相连的最短路径递增次序，从V-S中选择顶点放入S中（如路径`<v0,v1>,<v0,v1,,v3>`）。
（4）整个过程保证v0到集合S中的各点路径都比到V-S中各点路劲要短。
![](vx_images/1213102111058.png)                        ![](vx_images/5372602129484.png =530x)
>**证明**此法的可行性：反证法证明
>假设：此路径上有一个顶点不在S中，则表示有1个终点不在S，路径却比此路径短的路径。
>证：这不可能，因为算法是长度递增的次序来产生路径的，所以比此路径短的均已产生，其终点也在S中，与上面的假设相冲突。

```c++
// 迪杰斯特拉算法，对邻接矩阵求最短路径。
void Djstl(cInfo G,int v0,int path[BOX_LEN]) {
	/*
	D[]：记录权重。
	S[]：记录顶点是否已经访问过，对应算法中的集合S。
	path[]：存放对应位置顶点的前驱节点位置。本身即为引用型，所以不用&
	*/
	int D[BOX_LEN];
	bool S[BOX_LEN];

	int n = G.vexnum;
	// 初始化
	for (int v = 0; v < n;++v) {
		S[v] = false;
		D[v] = G.arcs[v0][v];							//v0到各终点的最短路径初始为权值。
		if (D[v] < MAX) path[v] = v0;
		else path[v] = -1;
	}
	S[v0] = true;
	D[v0] = 0;
	// 主体部分，求v0到每个顶点v的最短路径。
	int v,min;
	for (int i = 1; i < n; ++i) {
		min = MAX;
		// 循环找到与点v0权重最短的点
		for (int w = 0; w < n; ++w) {
			if (!S[w] && D[w] < min) {
				v = w;
				min = D[w];
			}

		}
		// 将与其最近的点加入集合。
		S[v] = true;
		// 再循环找距离v最近的点。
		for (int w = 0; w < n; ++w) {
        //V0-V-Vw的权重和小于v0-Vw的话，则更新
			if (!S[w] && (D[v] + G.arcs[v][w] < D[w])) {
				D[w] = D[v] + G.arcs[v][w];
				path[w] = v;			//最后的路径即为path。
			}
		}
	}
	
}
```
- **佛洛依德算法**：将 Vi（起点）到vj（终点）的最短路径长度初始化，然后进行n次比较和更新。<b c=r>求的是两个顶点间的最短路径</b>
（1）在Vi 和 VJ间加入顶点v。 比较 (Vi, Vj) 和 (Vi, Vo, VJ) 的路径长度，取其中较短者作为Vi到 VJ 的中间顶点序号不大于 0的最短路径。
（2）在Vi和 vj 间加入顶点V1, 得到 (Vi,…V1) 和 (V1,…,Vj)， 其中 (Vi..V1) 是Vi到VJ的且中间顶点的序号不大千 0 的最短路径。找vi-v1、v1-vj之间的最短路径中间点;
（3）得到（vi..v1..vj）与上一次求的最短路径（vi,v0,vj）比较，选较短的作为最短路径。
（4）重复2,3步骤。

```c++
/*============================
D[[1,5,3,7],[4,5,3,1],..]        //矩阵存储各路径的权重
path[[1,5,3,7],[4,5,3,1],..]     //矩阵存储点Vi，到Vj时，需要经过的Vj的前驱节点序号。这样从Vj开始反向遍历，即可求出Vi-Vj完整路径
==============================*/
for (int i=0; i < G. vexnum; ++){
    for(j=0;j <G.vexnum;++j){
        D[ i ][ j ] = G.arcs[ i ][ j ] ;
        if(D[i][j]<Maxint) Path[i][j]=1; //如果 l.和］之间有弧，则将j的前驱置为l.
    }
}

//如果 i和j之间无弧，则将j的前驱置为-1
for (int k=0; k < G. vexnum; ++k){
    for (int i=0; i <G.vexnum;++i) {
        for(int j=0;j <G.vexnum;++j){
            // Vi-Vk-Vj与Vi-Vj比较
            if(D[i] [k]+D[k] [j] <D[i] [j]) ｛ 
                D[i] [j]=D[i] [k]+D[k] [j];     //更新两点间路径大小
                Path[i] [j]=Path[k] [j];         //更新路径
            ｝
        }
    }
}
```

**AOV网**：activity on vertex network，用弧表示两个节点间优先关系的有向图称为顶点表示活动的网。有向无环图。
>关键路径：从开始点到终点，最长的路径称为关键路径。<b c=r>缩短关键路径可以加快完成整个活动，如果存在多条一样大的关键路径，需要都缩短才能加快</b>
>关键活动：关键路径上的活动为关键活动。

**拓扑排序**：aov网中不应该存在环，为检测网中是否有环需要进行拓扑排序，还**可以利用深度优先遍历**算法。
- 在有向图中选一个无前驱的顶点且输出它。
- 从图中删除该顶点和所有以它为尾的弧。
- 重复 (1) 和 (2), 直至不存在无前驱的顶点。
- 若此时输出的顶点数小千有向图中的顶点数，则说明有向图中存在环， 否则输出的顶点序列即为一个拓扑序列。
>**算法实现思路**：
>（1）求出各顶点的入度数，存入数组indegre中，将入度为0的顶点入栈；
>（2）只要栈不为空就将栈顶点Vi出栈，保存在拓扑序列数组top中；
>（3）对Vi的每个邻接点入Vk度-1，如果Vk入度变为0，则将Vk入栈；
>（4）如果最后top中元素个数小于图中顶点数，则存在环，否则拓扑排序成功；

## 七、查找：
1. 查找成功时的平均长度：
>$ASL=\sum_{i=1}^{n}P_iC_i其中p_i为查找表中第i个的概率，c_i为查找到第i个时和给定值已经比较过的关键字的个数。$
2. 顺序查找：从表头开始将关键字与给定值比较，一样则算查找成功。
3. 折半查找：也称二分查找，要求线性表必须采用顺序存储结构。从表中间开始查找，若与给定值相同则查找成功，否则再查找剩下的一半的中间值，依次反复。时间复杂度$O(\log_2N)

4. 分块查找：性能介于顺序查找和折半查找之间。先将一整个表按长度均分为几个子表(块)，然后为各块建立一个索引表，内容为其子表开始值的指针及该子表最大关键字。查找时：先将给定值与索引表的比对，确定在哪一个字表中，然后在该子表范围顺序查找。
>最佳分块数：假设共n个元素，每个块分为$\sqrt{n}，块数m=n/\sqrt{n}$是最合适的。

5. 树表查找：
**平衡二叉树**：为了避免二叉搜索树变成“链表”，我们引入了平衡二叉树，即让树的结构看起来尽量“均匀”，左右子树的节点数尽量一样多。又称AVL树，指的是左子树上的所有节点的值都比根节点的值小，而右子树上的所有节点的值都比根节点的值大，且左子树与右子树的高度差最大为1。构造如下：
先按照生成二叉搜索树的方法构造二叉树，直至二叉树变得不平衡，即出现这样的节点：左子树与右子树的高度差大于1。至于如何调整，要看插入的导致二叉树不平衡的节点的位置。主要有四种调整方式：LL（左旋）、RR（右旋）、LR（先左旋再右旋）、RL（先右旋再左旋）。[详细构建参考学习地址。](https://blog.csdn.net/winder9898/article/details/51098211)
[平衡二叉树参考学习地址。](https://baijiahao.baidu.com/s?id=1646617486319372351&wfr=spider&for=pc)

**B-树**：用于磁盘文件这种大数据量处理，B-树为系统最优化大块数据的读和写操作。
- **性质**：对于m层的B树
（1）树中每个节点至多有m颗子树。
（2）除根节点外的所有**非终端节点**，至少有m/2棵子树。
（3）所有叶子节点都在同一层上（体现平衡特点）。
（4）所有终端节点至少有m-1个关键字（排序使用！每个节点中的关键字都有序）。

**B+树**：B-树的变形，**差异**有如下：
- 有n棵子树的结点中含有n个关键字；
- 所有的叶子结点中包含了全部关键字的信息，以及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；
- 所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大或最小关键字。

B与B+相同点：都是平衡的多叉树、都可用于文件索引结构、都能有效地支持随机索引。
**散列表**：一个有限，连续的地址空间。查找时直接由给出的关键字，经过设计好的散列函数，计算映射出对应的存储地址。
- 散列值的冲突：因为关键字可以是任意的，空间很大，但存储空间却有限。所以是可能两个不同的明文得到相同的加密串（这也是md5算法可破解的原因）。
- 冲突处理方法：
    1. 开放地址法：把记录都存储在散列表数组中，当某一记录关键字 key的初始散列地址`=H0H(key)`发生冲突时，以H0为基础 ，采取合适方法计算得到另一个地址H1。依次解决
    2. 线性探测法：将散列表假想成一个循环表，发生冲突时，从冲突地址的下一单元顺序寻找空单元，如果到最后 一个位置也没找到空单元，则回到表头开始继续查找。
    3. 二次探测法、伪随机探测法。
    4. 链地址法：把具有相同散列地址的记录放在同一个单链表中，称为同义词链表。有 m 个散列地址就有 m 个单链表，同时用数组 HT[O…m-1]存放各个链表的头指针。
- 散列函数设计：**设计考虑**：表长、关键字长、关键字分布情况、计算所需时间。**设计遵循**（函数计算简单、函数值域在表长范围内）
    1. 数字分析法：若提前知道关键字集合，且关键字由数字组合，可以选出分布较均匀的数字做关键字，以避免冲突。
    2. 平方取中法：一般关键字集合是未知的，一般取数与其平方的中间几位作为散列地址。
    3. 折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位） 作为散列地址，这种方法称为折叠法。
    4. 除留余数法：假设散列表表长为m, 选择一个不大千m的数p, 用p除关键字，除后所得**余数**为散列地址
## 八、排序：
**分为两类排序**：非线性时间比较类排序(通过比较来决定元素间的排序)，线性时间非比较类排序(不通过比较来决定元素间的排序)。(以下均是以从小到大的排序为从下到大)。
**排序的稳定性**：若要排序的各元素关键字是唯一的，哪么任何排序算法所得结果是一样的。若其中存在两个以上关键字是相等的情况，排序前Ri=Rj，Ri在Rj前，若排序后反过来了，则称排序算法是不稳定的。当然各情况下需要选择合适的算法，不存在哪种排序算法更好的说法。
**内部排序外部排序**：要排序的内容稍小可以全部读取到内存中进行的排序情况称为内部排序，内容较多无法全部放入内存，需要向外存中依次读取的属于外部排序。
1. **冒泡排序**：`for(var i=0;i<arr.length-1;i++){for(var j=0;j<arr.length-i-1;j++){}}`对比相邻两个元素的大小排序，执行数组长度-1次即可排完。(i<len(dat)-1)。
>**特点**：**稳定**排序，可用于**链式存储结构**数据，由于移动数多，平均耗时比插入排序多，**适合初始记录无序，n不大时使用**。
2. **选择排序**：从中选择最大或最小的值放到开头，再从剩余之中重复次操作。**特点**：不稳定、可用于链式存储。简单选择排序**比较次数**与**移动次数**为`O(n^2)，O(n)`。
3. **插入排序**：【直接插入】从数组位置1开始然后比较0，1位置排序，再选择2位置在0，1，2中比较排序，...【折半插入】将值选取到之后插入已排好的序列中时使用折半查找的思想。
>**特点**：**稳定**排序、直接插入适用于**链式存储结构**、更适合**初始记录基本有序的情况**。折半插入由于折半查找算法原因适合**顺序存储结构**的，**适合初始记录无序，元素较多的情况**。
4. **希尔排序**：插入排序的一种，（1）取增量d1<n，所有序号间隔为d1的分为一组（如d1=5，序号0,5就是一组），各组中分中别直接进行插入排序(如序号5的数和0的数交换)。（2）去增量d2再分组，各组进行直接插入排序。（3）取到dt=1时即为所有元素放一起进行一次直接插入排序即可。
>**特点**：记录跳跃式的移动导致算法**不稳定**，只能用于**顺序存储结构**的数据，**适合初始记录无序，n较大情况**。
5. **快速排序**：从数列中挑出一个元素，称为 “基准”（pivot）；重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
>**特点**：不稳定的、排序过程中需要定位表的下界和上界，所以适合用于顺序结构，当n较大时，在平均情况下快速排序是所有内部排序方法中速度最快的一种，所以其适
合初始记录无序、 n较大时的情况。
6. **堆排序**：堆排序就是利用**堆**[^dui].这种数据结构建立的一种排序。属于树形排序
 - 细想：<b c=gn>建立初大根堆，调整堆</b>（去掉堆顶元素，将剩余的元素重新调整为大根堆）。利用筛选法来调整堆和建初堆。
 - **筛选法步骤**：假设D已经是一个有序的小根堆：`D=[5,8,12,19,28,20,15,22]`#现插入一个元素3（末尾插入）为满足小根堆需求必须调整堆。
（1）插入3后，3所在索引为8。算出其父节点索引：`K1=(8-2)/2=3`，再计算K1的父节点：`K2=(3-1)/2=1`，K2父节点索引0。<b c=b>索引从0开始，奇数-1，偶数-2</b>
（2）若`D[0]>D[8]`，则交换。若`D[3]>D[8]`则交换，若`D[1]>D[3]`则交换。若`D[0]>D[1]`则交换。
（a）建立堆时也是使用（1）（2）完成。<b c=b>删除大/x小根堆，堆顶元素后，把堆顶元素当做无穷小/大看待，然后使用筛选法调整</b>
 - 特点：是不稳定排序、只能用于顺序结构，不能用于链式结构 、记录较少时不建议使用，时间复杂度：$O(nlog_2 n)$//这里2是底数。
7. **计数排序**：例：有待排序的数组a和一个空数组b，求出a的最大最小值确定b的长度，扫描a根据其值依次将其放到b中对应下标位置处(如a[0]=12，a中为12的值的有3个那b[12]=3)全部放置完成后清空a将b中有值的位置根据其下标做为值放到a中。
桶排序：桶排序是计数排序的升级版，求出带排数组的最大最小值确定好桶数(空数组数)，分段的将其分到这些空数组中(例：<50的放到第1个空数组,>=50&&<110的放到第二个空数组...)各子数组使用其它排序算法或继续使用桶排序方法排好序，再按顺序将这些排好序的子数组拼接起来。
8. **基数排序**：是一种用多个关键字来排序的方法，如牌的花色和面值共同决定牌的大小。**最高位优先法**：先按不同 “花色 ” 分成 有次序的4堆， 每一堆的牌均具有相同的 “花色 ”，然后分别对每一堆按 “ 面值 ”大小整理有序。**最低位优先法**：先按不同面值分成13堆，然后各堆面值排序，合起来重新按照花色分堆，排序。
9. **归并排序**：（1）1,2进行对比排序，3,4进行对比排序...（2）1,2为一组，3,4为一组，这两组进行排序（内整体再排序），依次如此...
>**特点**：稳定、记录数大

**比较图表**：
| 排序方法    |  平均时间性能   |  最好时间性能   |  最坏时间性能   |  辅助存储空间   |  稳定性   |
| :-- | :-- | :-- | :-- | :-- | :-- |
|  直接插入排序   |  $O(n^2)$   |  $O(n)$   |  $O(n^2)$   |  $O(1)$   |  稳定   |
|  冒泡排序   |  $O(n^2)$   |  $O(n)$   |  $O(n^2)$   |  $O(1)$   |  稳定   |
|  简单选择排序   |  $O(n^2)$   |  $O(n)$   |  $O(n^2)$   |  $O(1)$   |  不稳定   |
|  快速排序   |  $O(nlog_2n)$   |  $O(nlog_2n)$   |  $O(nlog_2n)$   |  $O(log_2n)$   |  不稳定   |
|  堆排序   |  $O(nlog_2n)$   |  $O(nlog_2n)$   |  $O(nlog_2n)$   |  $O(1)$   |  不稳定   |
|  归并排序   |  $O(nlog_2n)$   |  $O(nlog_2n)$   |  $O(nlog_2n)$   |  $O(n)$   |  稳定   |
|  基数排序   |  $O(d(n+raddix))$   |   $O(d(n+raddix))$   |   $O(d(n+raddix))$   |  O(radix)   |  稳定   |


# 二、习题：
**基本概念**：
- 从逻辑上可把数据结构分为<b c=o>线性结构和非线性结构</b>。
- **数据的物理结构**，
（1）是指数据在计算机内存储的实际形式。
（2）数据结构中，数据的**基本单位**是`数据元素`，数据的**最小单位**是`数据项`
（3）包括**数据元素**的表示和**数据元素间关系**的表示。
（4）数据对象是指性质相同的数据元素的集合。

- 数据结构：
（1）是研讨数据的**逻辑结构和物理结构**，以及它们之间的相互关系，并对这种结构相应的**运算**，设计出相应的**算法**。
（2）是带有结构的`数据元素`的集合。
（3）研究内容包括：数据如何存储、数据如何组织、数据的运算如何实现。

- 计算机**算法**指的是**解决问题的步骤序列**，它必须有<b c=r>可执行性、确定性、有穷性</b>这3个特性。
- 算法的5个特性：有穷性、确定性、可行性、有零个或多个输入、有一个或多个输出。**算法的可行性**是指指令不能有二义性。
- **评价算法质量**：正确性、易读性、强壮性、高效率。健壮的算法不会因输入异常的数据而出现奇怪的状态。
- **时间复杂度**是指最坏情况下估算算法执行时间的一个上界。算法时间复杂度的数量级是指，根据时间复杂度，估计它处理的数据的量（如数组长度）。如：一个算法的时间复杂度为`(n3+n2log2n+14n)/n2`,其数量级表示为o(n)。解析：原式<=>n+log2n+14/n，最大的是n。

**数据的结构相关**：
- **栈**是一种实现数据流动方式的方法，**与存储数据无关**。**串、队列、堆、栈**是线性结构的。有序表只是逻辑结构。
- n个元素入栈，可得到：$\frac{(2n)!}{n!(n+1)!}$种**出栈顺序**。
- 两个栈**共享一个内存空间**时，把它们栈底分别设在空间地址两端。**栈满条件**：`top[1]+1=top[2]`
- 节点M,N的关系时M:N，这是一种图的数据结构。
- 数据结构的抽象操作的定义与具体实现**无关**。数据结构的基本操作设置的**最重要准则是**，实现应用程序与存储结构的独立。
- 对n个元素可构造出的逻辑结构有：集合、线性结构、树形结构、图状结构。
- 一个数据结构在计算机中的**表示(映像)**称为存储结构。
- **抽象数据类型**的定义仅取决于它的一**组逻辑特性**，与在**计算机内部如何表示和实现无关**，只要其数学特性不变，都不影响在外部的使用。3个组成部分分别为：数据对象、数据关系、基本操作。
- 开放地址法处理散列表冲突时，其平均长度**高于链接法处理冲突**。
- 链表存储二叉树时，n个节点的二叉树有2n个指针域，n-1个空指针。（**不要算上头指针**）
- 二叉树中，<b c=r>度为0的节点个数总是比度为2的节点个数多1.</b>
- n个节点，e条边的有向图和无向图的邻接表的边节点是，e和2e。（因为有向图邻接表中只指向箭头方向，所以无向图的是其2倍）
- **输出受限的双端队列**：是指删除限制在一段进行，但两端都可以插入的队列
- 链接方式存储的队列，插入时**可能队首队尾指正都要修改**！？？

- 快速排序在最坏情况下的时间复杂度为o(n^2)。
- 进行二分查找时，二分的序列以floor()后结果为准。
- (2,5,8,20,25,36,40,60)中折半查找60的比对顺序为：`20,36,40,60`

题1：表达式`a*(b+c)-d`的后缀表达式是：`abc+*d-`#栈底-栈顶。中缀表达式：`(A+B)*(C-D)/(E-F*G)`的后缀表达式：`AB+CD-*EFG*-/`#注意按从左到右的顺序扫描来。
题2：已知循环队列存储在一维数组`A[0,..,n-1`]中，队列非空时front分别指向队头和队尾元素，若初始时队列为空，要求第1个入队元素存储在A[0]，则此时的front，rear分别指向哪？
>解析：队列都是从**队尾插入**，但要求第1个存在A[0]，所以此时`front=0,rear=n-1`

题3：循环队列存放在一维数组A[0,..,M-1]中，end1指向队头元素，end2指向队尾元素的后一个位置，队列最多容纳M-1个元素，则判断队空和队满的条件？
>解析：为空时，end2也只能指向0，队满时因为只能容纳M-1个，此时end2=M-1。
>队空条件：`end1==end2`，队满条件：`end1==(end2+1) mod M`

题4：程序如下：用栈保存其调用过程，则栈中内容？
```c++
int s(int n){return n<=0 ? 0 : s(n-1) + n;}
void main(){cout << s(1);}
```
>解析：注意问的是栈保存调用的流程，而不是执行顺序。执行顺序是：main()->s(1)->s(0)，所以保存后，栈底-栈顶：main()->s(1)->s(0)

题5：设计一个判别表达式，求其中左右括号（[]）是否成对出现，用**栈结构**最好。递归过程或函数调用时，处理其参数要用**多维数组**处理。

**题6**：一颗完全二叉树有768个节点，则该二叉树中叶节点是？
>解析：`2^9-1<768<2^10-1`#所以该二叉树是10层，满二叉树情况应该有`2^10-1=1023`个节点，说明第10层少了`1023-768=255`个节点，<b c=v>一般根节点都算在内的</b>
>最后一层的叶节点数`=2^9-255=257`个，255是奇数，说明第9层有一个节点只有1个左节点，所以第9层叶节点数`=(255+1)/2 - 1= 127`
>所有叶节点数=257+127=384

**试题资源**：[资源1](https://wenku.baidu.com/view/3bc3c1ba3d1ec5da50e2524de518964bce84d2e7.html)。[资源2](https://wenku.baidu.com/view/da5218f06429647d27284b73f242336c1eb93085.html)、[资源3](https://wenku.baidu.com/view/56e70f5277c66137ee06eff9aef8941ea76e4b23.html)

[^dui]: **堆**：计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的**数组对象**{k1,k2,...,kn}，堆中某个节点的值总是不大于或不小于其父节点的值。满足性质：$k_i>=k_{2i}且k_i>=k_{2i+1}或k_i<=k_{2i}且k_i<=k_{2i+1}$，如序列{1,2,3,4,5,6}，其中1的Lnode->2,Rnode->3，2的Lnode->4,Rnode->5。
**堆总是一棵完全二叉树**。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。堆是**非线性数据结构**，相当于一维数组，有两个直接后继。
